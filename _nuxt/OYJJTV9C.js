import{R as a}from"./Caghk6Eh.js";class c extends a{constructor(){super(...arguments),this.CHIP_NAME="ESP32-C3",this.IMAGE_CHIP_ID=5,this.EFUSE_BASE=1610647552,this.MAC_EFUSE_REG=this.EFUSE_BASE+68,this.UART_CLKDIV_REG=1072955412,this.UART_CLKDIV_MASK=1048575,this.UART_DATE_REG_ADDR=1610612860,this.FLASH_WRITE_SIZE=1024,this.BOOTLOADER_FLASH_OFFSET=0,this.FLASH_SIZES={"1MB":0,"2MB":16,"4MB":32,"8MB":48,"16MB":64},this.SPI_REG_BASE=1610620928,this.SPI_USR_OFFS=24,this.SPI_USR1_OFFS=28,this.SPI_USR2_OFFS=32,this.SPI_MOSI_DLEN_OFFS=36,this.SPI_MISO_DLEN_OFFS=40,this.SPI_W0_OFFS=88}async getPkgVersion(s){const t=this.EFUSE_BASE+68+12;return await s.readReg(t)>>21&7}async getChipRevision(s){const n=this.EFUSE_BASE+68,e=3,t=18,o=n+4*e;return(await s.readReg(o)&7<<t)>>t}async getMinorChipVersion(s){const e=this.EFUSE_BASE+68+20,t=await s.readReg(e)>>23&1,r=this.EFUSE_BASE+68+4*3,i=await s.readReg(r)>>18&7;return(t<<3)+i}async getMajorChipVersion(s){const e=this.EFUSE_BASE+68+20;return await s.readReg(e)>>24&3}async getChipDescription(s){const n={0:"ESP32-C3 (QFN32)",1:"ESP8685 (QFN28)",2:"ESP32-C3 AZ (QFN32)",3:"ESP8686 (QFN24)"},e=await this.getPkgVersion(s),t=await this.getMajorChipVersion(s),o=await this.getMinorChipVersion(s);return`${n[e]||"Unknown ESP32-C3"} (revision v${t}.${o})`}async getFlashCap(s){const t=this.EFUSE_BASE+68+12;return await s.readReg(t)>>27&7}async getFlashVendor(s){const t=this.EFUSE_BASE+68+16,r=await s.readReg(t)>>0&7;return{1:"XMC",2:"GD",3:"FM",4:"TT",5:"ZBIT"}[r]||""}async getChipFeatures(s){const n=["Wi-Fi","BLE"],e={0:null,1:"Embedded Flash 4MB",2:"Embedded Flash 2MB",3:"Embedded Flash 1MB",4:"Embedded Flash 8MB"},t=await this.getFlashCap(s),o=await this.getFlashVendor(s),r=e[t],i=r!==void 0?r:"Unknown Embedded Flash";return r!==null&&n.push(`${i} (${o})`),n}async getCrystalFreq(s){return 40}_d2h(s){const n=(+s).toString(16);return n.length===1?"0"+n:n}async readMac(s){let n=await s.readReg(this.MAC_EFUSE_REG);n=n>>>0;let e=await s.readReg(this.MAC_EFUSE_REG+4);e=e>>>0&65535;const t=new Uint8Array(6);return t[0]=e>>8&255,t[1]=e&255,t[2]=n>>24&255,t[3]=n>>16&255,t[4]=n>>8&255,t[5]=n&255,this._d2h(t[0])+":"+this._d2h(t[1])+":"+this._d2h(t[2])+":"+this._d2h(t[3])+":"+this._d2h(t[4])+":"+this._d2h(t[5])}getEraseSize(s,n){return n}}export{c as ESP32C3ROM};
